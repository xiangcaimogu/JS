正课:
1. ***RegExp
2. Math
3. Date

1. ***RegExp:
  什么是: 封装一条正则表达式,
      提供使用该正则表达式执行验证和查找的API.  
  何时:
 1. 即查找每个关键词内容，又查找位置。
        2. 格式验证
  创建: 2种:
  1. 使用直接量: var reg=/正则/ig
     何时使用:如果正则表达式是固定的，不需要运行时动态生成。
     字符冲突: 直列量中，正则内部如果包含/需要转义为\/
  2. 使用new关键词:
      var reg=new RegExp("\\d","ig");
     何时使用:如果正则表达式需要在运行时动态生成！
      强调: 正则前后不需要加//
      字符冲突: 如果正则中包含",',\,都需要转义。
  
  API: 
  查找关键词:4种:
  1.查找固定关键词的位置：
    var i=str.indexOf("关键词",fromi);
   var i=str.lastIndexOf("关键词",fromi);
   问题:不支持正则
  2.判断有没有包含和正则匹配的关键词:
    var i=str.search(reg);
   问题:永远从0位置开始，始终只能找第一个
  3.获得所有关键词内容:
    var kwords=str.match(reg); //加g
   问题:无法获得每个关键词的位置
  4.即找每个关键词的内容，又找位置。
    var arr=reg.exec(str);
    在str中找下*一个*关键词的内容和位置，保存在数组arr中。
    补:reg对象的lastIndex属性:
       表示下次从lastIndex位置开始匹配
       默认为0
    原理:
     1.用reg去str中匹配一个关键词
     2.将本次找到的关键词内容，放在arr的第一个元素中，同时将关键词的位置，记录在arr.index属性中。
     3.自动将reg的lastIndex属性调整为当前位置之后。
    返回值:
      如果找到:同match不加g时
        arr[0]->本次找到的完整关键词
        如果正则中有分组：
          arr[1]->获得第1个分组的子内容
        arr.index->本次关键词的位置
      没找到:返回null
    如何使用: 用循环，反复调用exec，直到返回null为止。

  课堂练习: 
   正则: 
    贪婪模式:默认匹配尽量长的符合规则的字字符串。
    懒惰模式:让正则仅匹配最短的符合规则的字符串。
    贪婪改懒惰: .*?   .+?

  验证格式: 
  var bool=reg.test(str);
   验证str是否满足reg的格式要求。
   满足，返回true，不满足返回false
  强调: 一般验证都是要从头到尾完整匹配
       都要前加^，后加$。

2. Math:专门封装数学计算所用的API或常量
  何时使用:只要执行数学计算
  创建: Math不能new！
  API:所有API都用Math直接调用
  1. 取整:
    1. 上取整: 只要小数点超过，就取下一个整数
      num=Math.ceil(num)
    2. 下取整: 舍弃小数部分
      num=Math.floor(num);只能对纯数字下取整
      vs parseInt(str):
	转换为number
        去掉结尾的非数字字符
        舍弃小数部分
    3. 四舍五入取整:
      num=Math.round(num);
       强调：只能取整，不能设定小数位数
      vs n.toFixed(d)
       参数：round无法指定小数位置，只能取整
           toFixed(d)可指定小数位数，可按任意小数位数四舍五入。
       返回值: round返回num,可直接参与算术计算。
               toFixed(d)返回str，参与+法计算时，要提前类型转化。
     强调：小心舍入误差:
      
   2. 乘方和开平方:
    Math.pow(底数,幂)
    Math.sqrt(num) 开平方
       






